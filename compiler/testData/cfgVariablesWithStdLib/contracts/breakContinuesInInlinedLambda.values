== myRun ==
inline fun <T> myRun(block: () -> T): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block()
}
---------------------
                                                                                   <v0>: {<: () -> T}                      NEW: magic[FAKE_INITIALIZER](block: () -> T) -> <v0>
{ callsInPlace(block, InvocationKind.EXACTLY_ONCE) }                               <v1>: {<: ContractBuilder.() -> Unit}   NEW: r({ callsInPlace(block, InvocationKind.EXACTLY_ONCE) }) -> <v1>
contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }                      <v2>: *                                 NEW: call(contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }, contract|<v1>) -> <v2>
block                                                                              <v3>: {<: () -> T}                      NEW: r(block) -> <v3>
block()                                                                            <v4>: {<: T}                            NEW: call(block(), invoke|<v3>) -> <v4>
return block()                                                                     !<v5>: *
{ contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block() }   !<v5>: *                                COPY
=====================
== anonymous_0 ==
{
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
---------------------
                                                   <v0>: {<: ContractBuilder}   NEW: magic[IMPLICIT_RECEIVER](callsInPlace(block, InvocationKind.EXACTLY_ONCE)) -> <v0>
block                                              <v1>: {<: Function<T>}       NEW: r(block) -> <v1>
EXACTLY_ONCE                                       <v2>: {<: InvocationKind}    NEW: r(EXACTLY_ONCE) -> <v2>
InvocationKind.EXACTLY_ONCE                        <v2>: {<: InvocationKind}    COPY
callsInPlace(block, InvocationKind.EXACTLY_ONCE)   <v3>: *                      NEW: call(callsInPlace(block, InvocationKind.EXACTLY_ONCE), callsInPlace|<v0>, <v1>, <v2>) -> <v3>
callsInPlace(block, InvocationKind.EXACTLY_ONCE)   <v3>: *                      COPY
=====================
== getBoolean ==
fun getBoolean(): Boolean = false
---------------------
false   <v0>: Boolean   NEW: r(false) -> <v0>
=====================
== getBoolean ==
fun getBoolean() = false
---------------------
false   <v0>: Boolean   NEW: r(false) -> <v0>
=====================
== test ==
fun test() {
    val x: Int

    if (getBoolean())
        run {
            while (getBoolean()) {
                do {
                    run {
                        if (getBoolean()) {
                            x = 42
                        } else {
                            x = 43
                        }
                    }
                    break
                } while (getBoolean())
                run { x.inc() }
                run { x = 42 }
                break
            }
            x = 42
        }
    else
        run {
            x = 42
        }

    x.inc()
}
---------------------
getBoolean                                                                                                                                                                                                                         !<v0>: *
getBoolean()                                                                                                                                                                                                                       <v1>: Boolean           NEW: magic[UNRESOLVED_CALL](getBoolean()|!<v0>) -> <v1>
{ while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 }                                                                    <v2>: {<: () -> Unit}   NEW: r({ while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 }) -> <v2>
run { while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 }                                                                <v3>: *                 NEW: call(run { while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 }, run|<v2>) -> <v3>
{ x = 42 }                                                                                                                                                                                                                         <v4>: {<: () -> Unit}   NEW: r({ x = 42 }) -> <v4>
run { x = 42 }                                                                                                                                                                                                                     <v5>: *                 NEW: call(run { x = 42 }, run|<v4>) -> <v5>
if (getBoolean()) run { while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 } else run { x = 42 }                          <v6>: *                 NEW: merge(if (getBoolean()) run { while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 } else run { x = 42 }|<v3>, <v5>) -> <v6>
x                                                                                                                                                                                                                                  <v7>: Int               NEW: r(x) -> <v7>
inc()                                                                                                                                                                                                                              <v8>: *                 NEW: call(inc(), inc|<v7>) -> <v8>
x.inc()                                                                                                                                                                                                                            <v8>: *                 COPY
{ val x: Int if (getBoolean()) run { while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42 } else run { x = 42 } x.inc() }   <v8>: *                 COPY
=====================
== inlined anonymous_1 ==
{
            while (getBoolean()) {
                do {
                    run {
                        if (getBoolean()) {
                            x = 42
                        } else {
                            x = 43
                        }
                    }
                    break
                } while (getBoolean())
                run { x.inc() }
                run { x = 42 }
                break
            }
            x = 42
        }
---------------------
getBoolean                                                                                                                                                    !<v0>: *
getBoolean()                                                                                                                                                  <v1>: Boolean           NEW: magic[UNRESOLVED_CALL](getBoolean()|!<v0>) -> <v1>
{ if (getBoolean()) { x = 42 } else { x = 43 } }                                                                                                              <v2>: {<: () -> Unit}   NEW: r({ if (getBoolean()) { x = 42 } else { x = 43 } }) -> <v2>
run { if (getBoolean()) { x = 42 } else { x = 43 } }                                                                                                          <v3>: *                 NEW: call(run { if (getBoolean()) { x = 42 } else { x = 43 } }, run|<v2>) -> <v3>
break                                                                                                                                                         !<v4>: *
{ run { if (getBoolean()) { x = 42 } else { x = 43 } } break }                                                                                                !<v4>: *                COPY
getBoolean                                                                                                                                                    !<v5>: *
getBoolean()                                                                                                                                                  <v6>: Boolean           NEW: magic[UNRESOLVED_CALL](getBoolean()|!<v5>) -> <v6>
{ x.inc() }                                                                                                                                                   <v7>: {<: () -> Int}    NEW: r({ x.inc() }) -> <v7>
run { x.inc() }                                                                                                                                               <v8>: *                 NEW: call(run { x.inc() }, run|<v7>) -> <v8>
{ x = 42 }                                                                                                                                                    <v9>: {<: () -> Unit}   NEW: r({ x = 42 }) -> <v9>
run { x = 42 }                                                                                                                                                <v10>: *                NEW: call(run { x = 42 }, run|<v9>) -> <v10>
break                                                                                                                                                         !<v11>: *
{ do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break }                               !<v11>: *               COPY
42                                                                                                                                                            <v12>: Int              NEW: r(42) -> <v12>
x = 42                                                                                                                                                        !<v13>: *
while (getBoolean()) { do { run { if (getBoolean()) { x = 42 } else { x = 43 } } break } while (getBoolean()) run { x.inc() } run { x = 42 } break } x = 42   !<v13>: *               COPY
=====================
== inlined anonymous_2 ==
{
                        if (getBoolean()) {
                            x = 42
                        } else {
                            x = 43
                        }
                    }
---------------------
getBoolean                                     !<v0>: *
getBoolean()                                   <v1>: Boolean   NEW: magic[UNRESOLVED_CALL](getBoolean()|!<v0>) -> <v1>
42                                             <v2>: Int       NEW: r(42) -> <v2>
x = 42                                         !<v3>: *
{ x = 42 }                                     !<v3>: *        COPY
43                                             <v4>: Int       NEW: r(43) -> <v4>
x = 43                                         !<v5>: *
{ x = 43 }                                     !<v5>: *        COPY
if (getBoolean()) { x = 42 } else { x = 43 }   <v6>: *         NEW: merge(if (getBoolean()) { x = 42 } else { x = 43 }|!<v3>, !<v5>) -> <v6>
if (getBoolean()) { x = 42 } else { x = 43 }   <v6>: *         COPY
=====================
== inlined anonymous_3 ==
{ x.inc() }
---------------------
x         <v0>: Int   NEW: r(x) -> <v0>
inc()     <v1>: Int   NEW: call(inc(), inc|<v0>) -> <v1>
x.inc()   <v1>: Int   COPY
x.inc()   <v1>: Int   COPY
=====================
== inlined anonymous_4 ==
{ x = 42 }
---------------------
42       <v0>: Int   NEW: r(42) -> <v0>
x = 42   !<v1>: *
x = 42   !<v1>: *    COPY
=====================
== inlined anonymous_5 ==
{
            x = 42
        }
---------------------
42       <v0>: Int   NEW: r(42) -> <v0>
x = 42   !<v1>: *
x = 42   !<v1>: *    COPY
=====================
